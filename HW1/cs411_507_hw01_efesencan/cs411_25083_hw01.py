# -*- coding: utf-8 -*-
"""cs411_25083_hw01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JStNSWTRXp2z5Pl7JRDmBiaebq-sz3sF

## Question 1
"""

from sympy import *
import math

# question 1
print("********Question 1**********")
cipher = 'NYVVC'
for key in range(26):
  plain = ""
  for i in range(len(cipher)):
    shift = (ord(cipher[i]) - ord('A') - key) % 26
    plain += chr(ord('A') + shift)
  print(key,plain)  
print("*****************************\n")
# 10, DOLLS, 17, WHEEL

"""## Question 2"""

print("********Question 2**********")
# find the most frequent number in plain text
import collections
cipher = "Xpjjbxx lx eng klerm, krlmpob lx eng krgrm: lg lx gcb jnportb gn jneglepb gcrg jnpegx."
store_cipher = cipher.upper()
cipher = cipher.replace(' ','')
print(collections.Counter(cipher).most_common(1)[0])
# So T is mapped to G

cipher = cipher.upper()
alpha = [1,3,5,7,9,11,15,17,19,21,23,25] # possible alpha values
beta =  []
pairs = []
for i in alpha:   # calculate possible beta values
  beta_val = ((ord('G')- ord('A')) - ((ord('T') - ord('A')) * i)) % 26
  beta.append(beta_val)

for i,j in zip(alpha,beta): # store the alpha beta pairs
  pairs.append([i,j])

from sympy import *
# decrypt the affine cipher
for i in pairs:
    print(i)
    plain =  ""
    for j in store_cipher:
        if j.isalpha():
          alpha = i[0]
          beta  = i[1]
          y = ord(j) - ord('A')  
          number = (((y - beta) % 26) * (mod_inverse(alpha, 26))) % 26
          plain += str(chr(ord('A') + number))
        else:
          plain += j
    print(plain)
  
# alpha = 9, beta = 17 = (9,17)
# Message is : Success is not final, failure is not fatal: it is the courage to continue that counts.

# find decryption key
alpha = 9
beta = 17
gamma = mod_inverse(alpha, 26) # you can compute decryption key from encryption key
theta = 26-(gamma*beta)%26
print("Encryption keys are:",alpha,beta)
print("Decryption keys are:",gamma,theta)
print("*****************************\n")

"""## Question 4"""

# modulus is 31 x 31 x 31 = 29791
# number of alpha values could be phi(29791) = 28830  
# number of beta values  could be 29791
# key space is phi(29791) x 28830 = 858.874.530

"""## Question 5"""

print("********Question 5**********") # create new dictionary according to question 4
triad = {'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7, 'I':8, 'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14, 'P':15, 'Q':16, 'R':17, 'S':18, 'T':19, 'U':20, 'V':21, 'W':22, 'X':23, 'Y':24, 'Z':25,' ':26, '.':27, ',': 28, '!': 29, '?':30}
reversed_triad = {value : key for (key, value) in triad.items()}

mod = 29791
alpha = []   # find the possible alpha values
for i in range(1,mod): 
  if math.gcd(i,mod) == 1:
    alpha.append(i)
#print(len(alpha))

cipher = "IDSEOYLTVVDO?PSAUEKZO?LQIILQMP?LQNP!YSFNGSDBJZRZYTZTPS?EVYF,?LQ ,SAXSWTFXFD"

def getPairs(number): # returns the possible letter combinations that makes the number when multiplied with each other
  for i in range(0,31):
    for j in range(0,31):
      for k in range(0,31):
        if (i*(31*31) + j*(31) + k) == number:
          return i,j,k

def encode(pair,triad): # encode the letters based on the definition given in question 5
  return (triad[pair[0]]*31*31 + triad[pair[1]]*31 + triad[pair[2]]) % mod
  
key   = encode('.XX',triad)
value = encode('XFD',triad)

beta = []
pairs = []
for i in alpha: # find the possible beta values
  beta_val = (value -  ((key*i) % mod)) % mod
  beta.append(beta_val)

for i,j in zip(alpha,beta):
  pairs.append([i,j])
#print(pairs)

possibles = []
for t in pairs: # this process takes about 5 seconds
  #print(t)
  plain =  ""
  j = 0
  while j<=len(cipher) - 3:
    alpha = t[0]
    beta  = t[1]
    pair = cipher[j:j+3]
    j = j+3
    y = encode(pair,triad)
    number = (((y - beta) % mod) * (mod_inverse(alpha, mod))) % mod
    m,n,k = getPairs(number)
    
    plain += reversed_triad[m] + reversed_triad[n] + reversed_triad[k]
    
  #print(plain)
  if 'THE' in plain:
    print(plain)
    break # I have stored all possible plain texts that contains 'THE' and realized that the first plain text that contains THE is the answer, therefore I put break here  
print("*****************************\n")

"""## Question 6"""

# question 6, because of the hint, I guess the message starts with Dear student, So the key length is 6, (6,20,15,0,19,0)
print("********Question 6**********")
vigenere_cipher = "JYPR LTAXTNM, SOGELBCONN IL TNY ZER TU VGIELOUCCX, EXEPY LABUH"
count = 0
key_length = 6
plain = ""
key = [6,20,15,0,19,0]
for i in range(len(vigenere_cipher)):
  if vigenere_cipher[i].isalpha():
    if count % key_length == 0:
        count = 0
    plain += chr(((ord(vigenere_cipher[i]) - ord('A') - key[count]) % 26) + ord('A'))
    count += 1
  else:
    plain += vigenere_cipher[i]
print("Message of Prof. Erkay Savas:",plain)
print("*****************************\n")
# message is: DEAR STUDENT, SIMPLICITY IS THE KEY TO BRILLIANCE, ERKAY SAVAS

# question 7
print("********Question 7**********")
global possible_key_length
possible_key_length = 26
cipher = "Fwg atax: P’tx oh li hvabawl jwgvmjs, nw fw tfiapqz lziym,rqgv uuwfpxj wpbk jxlnlz fptf noqe wgw.Qoifmowl P bdg mg xv qe ntlyk ba bnjh vcf ekghnizl fq blidb eayz jgzbwx sqwm lgglbtqgy xlip.Pho fvvs ktf C smf ur ecul ywndxlz uv mzcz xxivw?Qomdmowl P bgzg, oblzqdxj C swas,B kyl btm udujs dcbfm vn yg eazl, pqzx,oblzq Q’ow mwmzb lg ghvk gxslz, emamwx apqu, wwmazagxv nomy bhlustk.”Ghm qvv’f nbfx h vqe vgoubdg, pgh’a nuvw shvbtmk kbvzq.Baam jqfg pafs ixetqm wcdanw svcKwn’df dixs mzy ziym llllmfa, zjid wxlbf nom eifw hlqspuglowall, loyv sztq cu btmlw mhuq phmmla.Kwn’df htiirk yul gx bf noqe kbls. Kwz’b agjl naz mzcuoe mekydpqzx:lblzq’a gg moqb nhj svc, fpxjy’z va zhsx.Uwi basn fwg’dx ouzbql rgoy tunx zyym, uv mzcz ayied wvzzmk,qib’dq lxknywkmw an ldqzroblzq qg lbl eazev."
vigenere_cipher = ""
for i in cipher:
  if i.isalpha():
    vigenere_cipher += i.lower()

letter_frequencies = [0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,
					  0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,
					  0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,
					  0.00978, 0.02360, 0.00150, 0.01974, 0.00074]

# returns the maximum number of overlap
def find_key_length(vigenere_cipher):
  count_overlap = dict()
  for i in range(1,possible_key_length):
      overlap = 0
      for j in range(0,len(vigenere_cipher)):
          if j+i <= len(vigenere_cipher)-1:
              if vigenere_cipher[j] == vigenere_cipher[j+i]:
                overlap += 1
          else:
              break
      count_overlap[i] = overlap

  max_key = max(count_overlap, key=count_overlap.get)
  return max_key

# figure out how the frequency distribution of the cipher text differs from actual english alphabet based on chi square test
# the smallest distribution difference would give us the correct shift amount 
def frequency_analysis(sequence):
  chi_squared_values = [0] * 26 # store the chi squared test values of all possible shift amounts
  for shift in range(26):
    chi_squared_value = 0.0
    observed_freq = {x: 0 for x in range(26)} # observed freq dict
    decrypted_sequence = ""

    for i in sequence: # first decrypt the letters with respect to the current shift amount
      decrypted_sequence += chr((((ord(i) - ord('a')) - shift) % 26) + ord('a'))

    for t in decrypted_sequence:  # store the letter occurences of the decrypted text
      observed_freq[ord(t) - ord('a')] += 1

    for k,v in observed_freq.items(): # store the letter frequencies
      observed_freq[k] *= observed_freq[k] / len(sequence)

    for j in range(26): # apply chi square test
      observed = observed_freq[j]
      expected = float(letter_frequencies[j])
      chi_squared_value += ((observed - (expected**2))/ expected)
    chi_squared_values[shift] = chi_squared_value
  

  shift_amount = chi_squared_values.index(min(chi_squared_values)) # return the index that has the minimum value of the chi square test, this will give us the correct shift amount
  return chr(shift_amount+ord('a'))

def find_key(cipher_text, key_length):
	key = ''

	for i in range(key_length):
		text_sequence=""
		# groups the sequence into chunks
		for j in range(0,len(cipher_text[i:]), key_length):
			text_sequence+=cipher_text[i+j]
		key+=frequency_analysis(text_sequence) # for each sequence apply frequency analysis

	return key

encryption_key = find_key(vigenere_cipher,find_key_length(vigenere_cipher))

count = 0
plain = ""
cipher = cipher.lower()
key = []
for i in encryption_key:
  key.append(ord(i) - ord('a'))
for i in range(len(cipher)):
  if cipher[i].isalpha():
    if count % len(encryption_key) == 0:
        count = 0
    plain += chr(((ord(cipher[i]) - ord('a') - key[count]) % 26) + ord('a'))
    count += 1
  else:
    plain += cipher[i]
print(plain)
print("*****************************\n")